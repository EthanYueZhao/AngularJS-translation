使用其他库的时候，你从#{&~ 众多}函数中挑选需要的使用。但Angular不是，它被设计成一个#{&= collaborative suit,协作套件}。本章将讲述Angular的基本组成，好让你理解它们是如何组合到一起的。在后面的章节，还会详细讲述这些基本组成。

调用Angular
===========

为了启动Angular，你的应用需要做两件事情：

1.加载 angular.js
2.通过ng-app告诉Angular管理哪部分DOM

加载脚本
--------

加载Angular和加载其他JavaScript库一样。你可以从Google的CDN加载：

```html
 <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.4/angular.min.js"></script>
```

推荐你是用Google的CDN。#{&~ 国内推荐使用国内的CDN或者下载下来放到你的服务器上。}Google的服务器速度快，脚本可以缓存，供不同的应用使用：如果你的用户使用了多个Angular开发的应用，她只需要下载一次。如果用户已经访问过使用了Google CDN上的angular.js的网站，她就不需要再为你的网站下载一份了。

如果愿意，你也可以将代码放在你的服务器（或其他服务器）。设置正确的src就可以了。

用ng-app声明Angular的作用范围
----------------------------

通过*ng-app*，你可以设置Angular的作用范围。如果你想创建一个全部使用Angular的应用，你应该将ng-app放在#{&< html}标签上，比如：

```html
<html ng-app>
...
</html>
```

这样，Angular将管理整个页面的DOM元素。

你还可以通过在如#{&< div}的元素上增加ng-app来向已有的Java、Rails等应用中引入Angular。

```html
<html>
	...
	<div ng-app>
		...
	</div>
</html>
```

模型/视图/控制器
================

在第一章我们提到过，Angular支持基于MVC的设计。虽然你可以灵活的设计你的Angular应用，但对于下面三个方面，你总会遵循某个风格：

- 描述应用状态的数据模型
- 展示数据的视图
- 协调模型和视图的控制器

通过创建对象属性，甚至是基本数据类型的数据就可以创建模型。模型变量#{&~ model variable}没有什么特别之处。如果你想呈现一段文字给用户，你定义一个字符串就可以了：

```javascipt
var someText = 'You have started your journey.';
```

通过创建模板，并将模型中的数据插入其中就可以创建视图。你已经在前面章节见过，你可以在DOM中放一个占位符：

```html
 <p>{{someText}}</p>
```
这称之为#{&= double-curly,双花括弧}插值语法，它会在模板中插入新的内容。

控制器是JavaScript类#{&~ 函数}或者#{&? 某种类型}。通过设置传入的*$scope*变量的属性，告诉Angular你的数据模型由哪些对象或基本类型构成:

```javascript
function TextController($scope){
	$scope.someText = someText;
}
```

将上面的代码片段整合起来：

```html
<html ng-app>
	<body ng-controller="TextController">
		<p>{{someText}}</p>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.1/angular.min.js"></script>
		<script>
			function TextController($scope){
				$scope.someText = 'You have started your journey.';
			}
		</script>
	</body>
</html>
```

在浏览器中打开上面页面，你将看到

> You have started your journey.

上面这种基本模型在简单情况下工作得很好。对于大多数应用，你还是希望创建模型对象来容纳你的数据。我们下面创建一个消息模型#{&~ message model}来保存someText。所以，将

```javascript
	var someText = 'You have started your journey.';
```

替换为

```javascript
var messages = {};
messages.someText = 'You have started your journey.';
function TextController($scope){
	$scope.messages = messages;
}
```

模板修改为

```html
 <p>{{messages.someText}}</p>
```

在后面我们会讨论这个*$scope*对象。像这样创建模型可以避免由*$scope*的#{&? 原型链}带来的不可预知的行为。

在全局定义*TextController*并不是一个最佳实践。将之定义为某个模块的一部分可以避免不必要的麻烦。模块为你的应用相关部分提供一个名字空间。下面改用名字空间重写上面代码：

```html
<html ng-app="myApp">
	<body ng-controller="TextController">
		<p>{{someText.message}}
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.1/angular.min.js"></script>
		<script>
			var myAppModule = angular.module('myApp',[]);
			myAppModule.controller('TextController',function($scope){
				var someText = {};
				someText.message = 'You have started your journey.';
				$scope.someText = someText;
			})
		</script>
	</body>
</html>
```

在这个版本中，我们设置了*ng-app*对应的模块为*myApp*。然后用*angular.module*定义了*myApp*模块，最后用将控制器对应的函数传给模块的*controller*函数，定义了*TextController*。

我们在后面会想些解释为什么这么写。现在，你只需记住通过使用模块避免创建全局对象是一个最佳实践。

模板和数据绑定
=============

Angular中的模板和从服务器获取的，#{&< script}标签中定义的静态资源一样，只是普通的HTML文档。你可以使用标准HTML和Angular#{Directive}创建UI组件。

一旦被浏览器解析，Angular将数据填充到模板中并展开，形成最终的应用。我们在第一章显示购物列表的时候见识过：

```html
 <div ng-repeat="item in items">
	<span>{{item.title}}</span>
	...
 </div>
```

上面代码中，*items*数组中的每个元素都会对应复制一份#{&< div}及其子元素的拷贝。

这些数据是从哪儿来的？在购物车实例中，我们在代码中定义了这些数据。#{&~ 在数据中定义数据}在测试UI的时候很方便使用。但是对于大多数应用来说都会从远端服务器请求持久化的数据。在浏览器中，你的应用连接服务器，请求需要的数据，填充模板，呈现结果给用户。

基本流程如下：

1.用户请求你的应用首页
2.用户浏览器建立HTTP连接，加载包含模板的index.html页
3.Angular被加载，等待页面完全加载后，寻找ng-app来确定作用范围
4.Angular遍历模板，查找各种#{Directive}和绑定。最终，DOM节点被创建、修改，事件监听器被注册，初始数据被请求，模板被转化为DOM树。
5.你在适当的时候，连接服务器加载其他数据并显示给用户

对于每个Angular应用来说，第一步到第三部是一样的。第四步和第五步根据你的需求，需要自定义。这些步骤可能是同步或者异步发生的。为了提高性能，避免多余请求，首屏数据可以和模板一并获取。

通过使用Angular组织你的应用，模板和对应的数据被分离开。这样模板可以被缓存，新的数据从服务端加载。和JavaScript文件，图片，CSS，其他资源一样，缓存模板可以提升应用的性能。

显示文字
-------

通过使用*ng-bind*#{Directive}，你可以在UI的任何地方显示更新文本。有两种等价的写法，一种我们已经见过，即#{&= double-curly}语法:

```html
 <p>{{greeting}}
```

另外一种写法是基于#{Directive}的：

```html
 <p ng-bind="greeting"></p>
```

两种写法输出结果是一样的。如果模型变量#{&~ model variable} 'greeting'被设置为 "Hi there",Angular将会生成如下HTML片段：

```html
 <p>Hi there</p>
```

浏览器会显示 "Hi there"。

话说回来了，为什么要有两种写法呢？是这样的，#{&= double-curly}语法开起来更自然易读，代码量更少。虽然两种写法都产生同样的HTML，#{&= double-curly}的写法在首屏显示的时候，在数据没有填充前，可能会被用户看到。后续的视图不会有这个问题。

会被用户看到未填充的模板是因为，只有当浏览器完全下载页面之后，Angular才有机会解析模板。好消息是，在大多数情况下，你都可以使用#{&= double-curly}语法来书写模板。在首页，你可以使用*ng-bind*的写法避免模板被看到的问题。


表单输入
--------

Angular中使用表单元素很简单。像之前实例所示，你可以用*ng-model*将元素和数据模型的属性绑定起来。这种方法适用于所有标准的表单元素，比如输入框#{&~ inputs}，单按按钮#{&~ radio buttons}，勾选框#{&~ checkboxs}等等。我们可以这样绑定一个checkbox和某个属性：

```html
 <form ng-controller="SomeController">
 	<input type="checkbox" ng-model="youCheckedIt">
 </form>
```

解释：
1.当用户选择/取消勾选框的时候，*$scope*的youCheckedIt属性将会被设置为true/false。
2.如果你在SomeController中将*$scope.youCheckedIt*设置为true/false，那么勾选框将被选中/未选中。

现在，我们希望用户做出某个行为时做点事情。为输入框增加*ng-change*#{Directive}并指定控制器的一个方法，当输入框的内容发生变化的时候，这个方法会被调用。下面我们实现一个简单的计算器，帮助#{&.. what's startup owners?}

```html
 <form ng-controller="StartUpController">
 	Starting: <input ng-change="computeNeeded()" ng-model="funding.startingEstimate">
 	Recommendation: {{funding.needed}}
 </form>
```

为了简化问题，我们直接将输出设为用户估值的十倍，并把初始估值设置为0：

```javascript
function StartUpController($scope){
	$scope.funding = {startingEstimate: 0};
	$scope.computeNeeded = function(){
		$scope.needed = $scope.startingEstimate * 10;
	};
}
```

这段代码里有一个潜在的问题：当用户输入时，我们只重算了需要的数量。如果输入框仅在用户输入时得到更新，那么不会有问题。但如果其他输入框也绑定了这个属性会怎么样？如果输入框是因为服务器有新数据过来而更新的又会如何？

为了避免上面的问题，我们可以使用*$scope.$watch*函数来监控一个表达式，每当表示发生变化都会调用你提供的回调函数。这是最基本的用法，后面我们还会详细介绍*$watch*。

在这个例子中，我们希望监控*funding.startingEstimate*,在它发生变化的时候调用*computeNeeded*。重写上面代码:

```javascript
function StartUpController($scope){
	$scope.funding = {startingEstimate: 0};
	var computeNeeded = function(){
		$scope.funding.needed = $scope.funding.startingEstimate * 10;
	};

	$scope.$watch('funding.startingEstimate',computeNeeded);
}
```

注意，监控的表达式是一个字符串。这个字符串叫做Angular表达式。 表达式里可以做简单的运算，可以访问*$scope*的属性。我们会在后面详细介绍Angular表达式。

你也可以监控函数的返回值，但是监控*funding.startingEstimate*本身#{&~ 不是字符串哦}是不起作用的，因为他初始值是零，并且不再变化。

接下来，因为每当*funding.startEstimate*发生变化的时候，*funding.needed*都会发生变化，我们可以简化上面的模板：

```html
 <form ng-controller="StartUpController">
 	Starting: <input ng-model="funding.startingEstimate">
 	Recommendation: {{funding.needed}}
 </form>
```

在有些情况下，你希望当用户明确通知你她准备好了，然后再做处理，而不是每次发生变化都做处理。比如下单或者发送一段#{&~ 写好的}聊天消息。

如果你有一个form，里面有一组input。你可以给form设置一个*ng-submit*#{Directive}来指定form提交时需要调用的函数。我们扩展一下之前的实例，让用户可以通过点击一个按钮来#{&? 请求启动资金}：

```html
 <form ng-submit="requestFunding()" ng-controller="StartUpController">
 	Starting: <input ng-change="computeNeeded()" ng-model="startingEstimate">
 	<button>Fund my startup!</button>
 </form>
```
```javascript
function StartUpController($scope){
	$scope.computeNeeded = function(){
		$scope.needed = $scope.startingEstimate * 10;
	};

	$scope.requestFunding = function(){
		alert("Sorry, please get more customers first.");
	};
}
```

*ng-submit*#{Directive}会在提交表单时，自动阻止浏览器默认的POST动作。

为了处理其他用户交互，Angular还提供了其他事件处理的#{Directive}，比如，与*onclick*对应的是*ng-click*，与*ondblclick*对应的是*ng-dblclick*,等等。

通过扩展上面的实例我们来试一试：增加一个重置按钮，将输入设置为零。

```html
 <form ng-submit="requestFunding()" ng-controller="StartUpController">
 	Starting: <input ng-change="computeNeeded()" ng-model="startingEstimate">
 	Recommendation: {{needed}}
 	<button>Fund my startup!</button>
 	<button ng-click="reset()">Reset</button>
 </form>
```
```javascript
function StartUpController($scope){
	$scope.computeNeeded = function(){
		$scope.needed = $scope.startingEstimate * 10;
	};
	$scope.requestFunding = function(){
		alert("Sorry, please get more customers first.")
	};
	$scope.reset = function(){
		$scope.startingEstimate = 0;
	};
}
```

关于#{&? Unobtrusive JavaScript}的一些建议#{&...}
--------------------------------------



